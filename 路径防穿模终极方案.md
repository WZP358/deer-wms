# 路径防穿模终极方案

## 🎯 核心理解（正确版本）

用户的比喻非常准确：**像人在两排房子之间的路上走，走在路的正中间，不会穿过房子**。

访问格子时，**必须经过格子正下方边的中间点**才算访问了该格子。

## 📐 坐标系统详解

### 网格结构

```
4列布局（layoutCols = 4），gridCols = 9

gridCol:  0   1   2   3   4   5   6   7   8
        ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
row 0   │ 通│ G1│ 通│ G2│ 通│ G3│ 通│ G4│ 通│ ← 水平通道（可走）
        ├───┼───┼───┼───┼───┼───┼───┼───┼───┤
row 1   │ 通│ G1│ 通│ G2│ 通│ G3│ 通│ G4│ 通│ ← 格子行
        ├───┼───┼───┼───┼───┼───┼───┼───┼───┤
row 2   │ 通│ G1│ 通│ G2│ 通│ G3│ 通│ G4│ 通│ ← 水平通道（可走）
        └───┴───┴───┴───┴───┴───┴───┴───┴───┘
          ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑
          垂  格  垂  格  垂  格  垂  格  垂
          直  子  直  子  直  子  直  子  直
          通  中  通  中  通  中  通  中  通
          道  心  道  心  道  道  道  心  道

格子G1在 (1, 1) - 奇数坐标
访问G1时，目标在 (2, 1) - 格子正下方的中间点
```

### 坐标类型

- **偶数行（0, 2, 4...）**：水平通道（两排格子之间的横向路）
- **奇数行（1, 3, 5...）**：格子行（不能走在这里，除非是访问格子的目标点）
- **偶数列（0, 2, 4...）**：垂直通道（格子之间的纵向缝隙）
- **奇数列（1, 3, 5...）**：格子中心列（访问格子时经过这里）

### 路径规则

路径点必须满足以下之一：
1. **(偶数行, 偶数列)** - 通道交叉点 ✓ 最安全
2. **(偶数行, 奇数列)** - 在水平通道中，经过某格子的下方/上方 ✓ 访问格子时
3. **(奇数行, 偶数列)** - 在垂直通道中，经过某格子的左侧/右侧 ✓ 可能用到
4. **(奇数行, 奇数列)** - 在格子上 ❌ 绝对不行

## 🔧 正确的实现

### 1. 目标位置计算

```javascript
getAreaPositionById(areaId) {
    const cell = this.displayCells.find(item => item.area && item.area.areaId === areaId);
    if (!cell) return null;
    
    // 返回格子正下方的中间点
    return {
        row: cell.gridRow + 1,  // 格子下方的水平通道（偶数）
        col: cell.gridCol       // 格子中心列（奇数）
    };
}
```

**示例：**
- 格子在 (1, 1)，目标在 (2, 1) ✓
- 格子在 (3, 5)，目标在 (4, 5) ✓
- 格子在 (1, 7)，目标在 (2, 7) ✓

### 2. 入口位置计算

```javascript
getEntrancePosition() {
    const middleCell = Math.max(1, Math.ceil(this.boardMetrics.layoutCols / 2));
    const col = (middleCell - 1) * 2;  // 偶数（通道列）
    return {
        row: 0,  // 顶部通道（偶数）
        col: col // 中间通道（偶数）
    };
}
```

入口在 (0, col)，都是偶数，在通道交叉点上 ✓

### 3. Canvas坐标转换（关键！）

```javascript
const pathPoints = this.pathData.path.map(pos => {
    const paddingPx = 8;
    
    // X坐标：区分通道列和格子列
    let x;
    if (pos.col % 2 === 0) {
        // 偶数列（垂直通道）：走在通道正中间
        x = (pos.col / 2) * cellWidth + paddingPx;
    } else {
        // 奇数列（格子中心）：走在格子中心线上
        x = Math.floor(pos.col / 2) * cellWidth + cellWidth / 2;
    }
    
    // Y坐标：区分通道行和格子行
    let y;
    if (pos.row % 2 === 0) {
        // 偶数行（水平通道）：走在通道正中间
        y = (pos.row / 2) * cellHeight + paddingPx;
    } else {
        // 奇数行（格子中心）：走在格子中心线上
        y = Math.floor(pos.row / 2) * cellHeight + cellHeight / 2;
    }
    
    return { x, y, gridRow: pos.row, gridCol: pos.col };
});
```

## 🎨 Canvas坐标计算详解

### 示例：layoutCols = 4, canvasWidth = 900px

```
cellWidth = 900 / 4 = 225px（一个单元的总宽度）

一个单元包含：padding(8px) + 格子 + padding(8px)
格子宽度 = 225 - 16 = 209px

gridCol=0（通道）: x = 0 * 225 + 8 = 8px      ✓ 第0条通道中心
gridCol=1（格子）: x = 0 * 225 + 112.5 = 112.5px ✓ 第0个格子中心
gridCol=2（通道）: x = 1 * 225 + 8 = 233px    ✓ 第1条通道中心
gridCol=3（格子）: x = 1 * 225 + 112.5 = 337.5px ✓ 第1个格子中心
gridCol=4（通道）: x = 2 * 225 + 8 = 458px    ✓ 第2条通道中心
```

### 路径示例

访问格子(1,1)和格子(1,3)：

```
入口(0,2) → 格子1目标(2,1) → 格子2目标(2,3)

Canvas坐标：
- 入口: (233px, 8px)
- 目标1: (112.5px, 233px)  ← 在格子1下方的中间
- 目标2: (337.5px, 233px)  ← 在格子2下方的中间

路径线条完全在通道中，访问格子时经过格子正下方！
```

## ✅ 验证方法

### 打开控制台查看

```javascript
路径规划参数: {
  start: {row: 0, col: 2},      // (偶数, 偶数) ✓
  targets: [
    {row: 2, col: 1},           // (偶数, 奇数) ✓ 格子下方
    {row: 2, col: 3},           // (偶数, 奇数) ✓ 格子下方
    {row: 2, col: 5}            // (偶数, 奇数) ✓ 格子下方
  ]
}
```

**验证规则：**
- 入口：两个都是偶数 ✓
- 目标：row是偶数，col是奇数 ✓

### 视觉验证

刷新页面后观察：
1. ✅ 路径在通道中间行走
2. ✅ 访问格子时，从格子正下方经过
3. ✅ 完全不穿过格子
4. ✅ 已走路径：彩色实线
5. ✅ 未走路径：灰色虚线

## 🎉 总结

### 核心原则

像人在两排房子之间走路：
1. **走在路的正中间**（通道中心或格子中心线）
2. **访问房子时从房子下方经过**（格子正下方边的中间点）
3. **绝对不穿过房子**（不走在格子上）

### 技术关键

1. **目标位置**：(gridRow + 1, gridCol) - 格子正下方
2. **Canvas转换**：区分偶数坐标（通道）和奇数坐标（格子中心）
3. **路径规则**：至少有一个坐标是偶数（在通道上）

### 更新的文件

1. `wms-admin/src/main/resources/static/ruoyi/in/areaOverview.js`
2. `wms-admin/src/main/resources/static/ruoyi/in/shelfOverview.js`
3. `wms-admin/target/classes/static/ruoyi/in/areaOverview.js`
4. `wms-admin/target/classes/static/ruoyi/in/shelfOverview.js`

---

**测试方法：硬刷新浏览器（Ctrl+F5），运行路径模拟，观察效果！**

